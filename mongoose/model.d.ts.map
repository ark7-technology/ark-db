{"version":3,"sources":["mongoose/model.ts"],"names":[],"mappings":"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","file":"model.d.ts","sourcesContent":["import 'reflect-metadata';\r\n\r\nimport * as _ from 'underscore';\r\nimport debug from 'debug';\r\nimport {\r\n  Document as MDocument,\r\n  DocumentToObjectOptions,\r\n  Model as MModel,\r\n  Mongoose,\r\n  Query,\r\n  Schema,\r\n  SchemaOptions,\r\n  SchemaTypes,\r\n} from 'mongoose';\r\nimport { MongoError } from 'mongodb';\r\n\r\nimport { A7ModelType } from './a7-model';\r\nimport { AsObject, AsObjectPartial, ConvertModel } from './types';\r\nimport { SBaseMongooseConfig, sbaseMongooseConfig } from './model-config';\r\nimport { extendMetadata, pushMetadata } from './helpers';\r\n\r\nconst d = debug('sbase:model');\r\n\r\nexport type ModelType = typeof Model;\r\nexport type IModel<E extends DocumentModel> = MModel<E>;\r\n\r\nexport interface Document extends MDocument {\r\n  toJSON(options?: DocumentToObjectOptions): AsObject<this>;\r\n}\r\n\r\nexport interface Model {\r\n  toJSON(options?: DocumentToObjectOptions): AsObject<this>;\r\n}\r\n\r\n/**\r\n * Wrapped Model from mongoose.Model.\r\n */\r\nexport class Model {\r\n  public static modelize<T extends new (...args: any[]) => any>(\r\n    this: T,\r\n    o: AsObjectPartial<InstanceType<T>>,\r\n  ): InstanceType<T> {\r\n    const p = {\r\n      toJSON() {\r\n        return this;\r\n      },\r\n    };\r\n    Object.setPrototypeOf(o, p);\r\n    Object.setPrototypeOf(p, this.prototype);\r\n    return o as any;\r\n  }\r\n\r\n  public static Schema(schema: Schema): ModelType {\r\n    extendMetadata(SCHEMA_KEY, this.prototype, schema);\r\n    return this;\r\n  }\r\n\r\n  public static Config(config: SchemaOptions): ModelType {\r\n    extendMetadata(CONFIG_KEY, this.prototype, config);\r\n    return this;\r\n  }\r\n\r\n  public static Pre(pre: Pre): ModelType {\r\n    pushMetadata(PRE_KEY, this.prototype, pre);\r\n    return this;\r\n  }\r\n\r\n  public static Post(post: Post): ModelType {\r\n    pushMetadata(POST_KEY, this.prototype, post);\r\n    return this;\r\n  }\r\n\r\n  public static Virtual(virtual: Virtual): ModelType {\r\n    pushMetadata(VIRTUAL_KEY, this.prototype, virtual);\r\n    return this;\r\n  }\r\n\r\n  public static Plugin(plugin: Plugin): ModelType {\r\n    pushMetadata(PLUGIN_KEY, this.prototype, plugin);\r\n    return this;\r\n  }\r\n\r\n  public static Index(index: Index): ModelType {\r\n    pushMetadata(INDEX_KEY, this.prototype, index);\r\n    return this;\r\n  }\r\n\r\n  public static Mixin(model: ModelType): ModelType {\r\n    pushMetadata(MIXIN_KEY, this.prototype, model);\r\n    return this;\r\n  }\r\n\r\n  public static UpdateValidator(validate: UpdateValidator): ModelType {\r\n    pushMetadata(UPDATE_VALIDATOR_KEY, this.prototype, validate);\r\n    return this;\r\n  }\r\n\r\n  public static $mongooseOptions(\r\n    sbaseConfig?: SBaseMongooseConfig,\r\n    tenancy: string = 'default',\r\n  ): MongooseOptions {\r\n    if (this === Model) {\r\n      return null;\r\n    }\r\n\r\n    d('generate $mongooseOptions for %O', this.name);\r\n\r\n    let mongooseOptionsMap: MongooseOptionsMap = Reflect.getOwnMetadata(\r\n      MONGOOSE_OPTIONS_KEY,\r\n      this.prototype,\r\n    );\r\n\r\n    if (mongooseOptionsMap && mongooseOptionsMap[tenancy]) {\r\n      return mongooseOptionsMap[tenancy];\r\n    }\r\n\r\n    const mongooseOptions: MongooseOptions = {};\r\n\r\n    mongooseOptionsMap = {\r\n      [tenancy]: mongooseOptions,\r\n    };\r\n\r\n    Reflect.defineMetadata(\r\n      MONGOOSE_OPTIONS_KEY,\r\n      mongooseOptionsMap,\r\n      this.prototype,\r\n    );\r\n\r\n    const superClass: ModelType = (this as any).__proto__;\r\n\r\n    const superOptions: MongooseOptions =\r\n      superClass.$mongooseOptions(sbaseConfig, tenancy) || {};\r\n\r\n    const mixinModels: ModelType[] = _.union(\r\n      Reflect.getOwnMetadata(MIXIN_KEY, this.prototype) || [],\r\n    );\r\n    const mixinOptions = _.map(mixinModels, (model) =>\r\n      model.$mongooseOptions(sbaseConfig, tenancy),\r\n    );\r\n\r\n    const schemas = _.flatten([\r\n      _.map(mixinOptions, (opt) => opt.schema),\r\n      superOptions.schema,\r\n      Reflect.getOwnMetadata(SCHEMA_KEY, this.prototype),\r\n    ]);\r\n    mongooseOptions.schema = _.extend({}, ...schemas);\r\n\r\n    const configs = _.flatten([\r\n      _.map(mixinOptions, (opt) => opt.config),\r\n      superOptions.config,\r\n      Reflect.getOwnMetadata(CONFIG_KEY, this.prototype),\r\n    ]);\r\n    mongooseOptions.config = _.extend({}, ...configs);\r\n\r\n    mongooseOptions.pres = _.filter(\r\n      _.union(\r\n        _.flatten([\r\n          _.map(mixinOptions, (opt) => opt.pres),\r\n          superOptions.pres,\r\n          Reflect.getOwnMetadata(PRE_KEY, this.prototype),\r\n        ]),\r\n      ),\r\n      (x) => !!x,\r\n    );\r\n\r\n    mongooseOptions.posts = _.filter(\r\n      _.union(\r\n        _.flatten([\r\n          _.map(mixinOptions, (opt) => opt.posts),\r\n          superOptions.posts,\r\n          Reflect.getOwnMetadata(POST_KEY, this.prototype),\r\n        ]),\r\n      ),\r\n      (x) => !!x,\r\n    );\r\n\r\n    mongooseOptions.virtuals = _.filter(\r\n      _.union(\r\n        _.flatten([\r\n          _.map(mixinOptions, (opt) => opt.virtuals),\r\n          superOptions.virtuals,\r\n          Reflect.getOwnMetadata(VIRTUAL_KEY, this.prototype),\r\n        ]),\r\n      ),\r\n      (x) => !!x,\r\n    );\r\n\r\n    mongooseOptions.updateValidators = _.filter(\r\n      _.union(\r\n        _.flatten([\r\n          _.map(mixinOptions, (opt) => opt.updateValidators),\r\n          superOptions.updateValidators,\r\n          Reflect.getOwnMetadata(UPDATE_VALIDATOR_KEY, this.prototype),\r\n        ]),\r\n      ),\r\n      (x) => !!x,\r\n    );\r\n\r\n    mongooseOptions.plugins = _.sortBy(\r\n      _.filter(\r\n        _.union(\r\n          _.flatten([\r\n            _.map(mixinOptions, (opt) => opt.plugins),\r\n            superOptions.plugins,\r\n            Reflect.getOwnMetadata(PLUGIN_KEY, this.prototype),\r\n          ]),\r\n        ),\r\n        (x) => !!x,\r\n      ),\r\n      (plugin) => plugin.priority,\r\n    );\r\n\r\n    mongooseOptions.indexes = _.filter(\r\n      _.union(\r\n        _.flatten([\r\n          _.map(mixinOptions, (opt) => opt.indexes),\r\n          superOptions.indexes,\r\n          Reflect.getOwnMetadata(INDEX_KEY, this.prototype),\r\n        ]),\r\n      ),\r\n      (x) => !!x,\r\n    );\r\n\r\n    mongooseOptions.methods = _.filter(\r\n      _.union(\r\n        _.flatten([\r\n          _.map(mixinOptions, (opt) => opt.methods),\r\n          superOptions.methods,\r\n        ]),\r\n      ),\r\n      (x) => !!x,\r\n    );\r\n\r\n    mongooseOptions.statics = _.filter(\r\n      _.union(\r\n        _.flatten([\r\n          _.map(mixinOptions, (opt) => opt.statics),\r\n          superOptions.statics,\r\n        ]),\r\n      ),\r\n      (x) => !!x,\r\n    );\r\n\r\n    for (const name of Object.getOwnPropertyNames(this.prototype)) {\r\n      if (name === 'constructor') {\r\n        continue;\r\n      }\r\n\r\n      const descriptor = Object.getOwnPropertyDescriptor(this.prototype, name);\r\n\r\n      if (descriptor.value && _.isFunction(descriptor.value)) {\r\n        mongooseOptions.methods.push({ name, fn: descriptor.value });\r\n      }\r\n\r\n      if (descriptor.get || descriptor.set) {\r\n        mongooseOptions.virtuals.push({\r\n          name,\r\n          get: descriptor.get,\r\n          set: descriptor.set,\r\n        });\r\n      }\r\n    }\r\n\r\n    for (const name of Object.getOwnPropertyNames(this)) {\r\n      const descriptor = Object.getOwnPropertyDescriptor(this, name);\r\n\r\n      if (STATIC_FILTER_NAMES.indexOf(name) >= 0) {\r\n        continue;\r\n      }\r\n\r\n      if (descriptor.value) {\r\n        mongooseOptions.statics.push({ name, fn: descriptor.value });\r\n      }\r\n    }\r\n\r\n    const collection =\r\n      sbaseConfig != null && mongooseOptions.config.collection\r\n        ? _.chain([\r\n            tenancy === 'default'\r\n              ? sbaseConfig.multiTenancy.defaultCollectionNamespace\r\n              : tenancy,\r\n            mongooseOptions.config.collection,\r\n          ])\r\n            .filter((x) => !!x)\r\n            .join('.')\r\n            .value()\r\n        : mongooseOptions.config.collection;\r\n\r\n    const mongooseSchema = new Schema(\r\n      mongooseOptions.schema,\r\n      _.extend(_.clone(mongooseOptions.config), { collection }),\r\n    );\r\n\r\n    (mongooseSchema as any).parentSchema = superOptions.mongooseSchema;\r\n\r\n    for (const pre of mongooseOptions.pres) {\r\n      d(\r\n        'create pre for %O with name %O and options %O',\r\n        this.name,\r\n        pre.name,\r\n        pre,\r\n      );\r\n      pre.parallel = pre.parallel || false;\r\n      mongooseSchema.pre(pre.name, pre.parallel, pre.fn, pre.errorCb);\r\n    }\r\n\r\n    for (const post of mongooseOptions.posts) {\r\n      d(\r\n        'create post for %O with name %O and options %O',\r\n        this.name,\r\n        post.name,\r\n        post,\r\n      );\r\n      (mongooseSchema as any).post(post.name, post.fn);\r\n    }\r\n\r\n    for (const virtual of mongooseOptions.virtuals) {\r\n      d(\r\n        'create virtual for %O with name %O and options %O',\r\n        this.name,\r\n        virtual.name,\r\n        virtual.options,\r\n      );\r\n      let v = mongooseSchema.virtual(virtual.name, virtual.options);\r\n      if (virtual.get) {\r\n        v = v.get(virtual.get);\r\n      }\r\n      if (virtual.set) {\r\n        v = v.set(virtual.set);\r\n      }\r\n    }\r\n\r\n    for (const method of mongooseOptions.methods) {\r\n      d(\r\n        'create method for %O with name %O and function %O',\r\n        this.name,\r\n        method.name,\r\n        method.fn,\r\n      );\r\n      mongooseSchema.methods[method.name] = method.fn;\r\n    }\r\n\r\n    for (const method of mongooseOptions.statics) {\r\n      mongooseSchema.statics[method.name] = method.fn;\r\n    }\r\n\r\n    for (const plugin of mongooseOptions.plugins) {\r\n      const options = _.extend({}, mongooseOptions.config, plugin.options);\r\n      mongooseSchema.plugin(plugin.fn, options);\r\n    }\r\n\r\n    for (const index of mongooseOptions.indexes) {\r\n      d(\r\n        'create index for %O with fields %O and options %O',\r\n        this.name,\r\n        index.fields,\r\n        index.options,\r\n      );\r\n      mongooseSchema.index(index.fields, index.options);\r\n    }\r\n\r\n    for (const validate of mongooseOptions.updateValidators) {\r\n      mongooseSchema\r\n        .path(validate.path)\r\n        .validate(\r\n          combineValidator(validate.fn),\r\n          validate.errorMsg,\r\n          validate.type,\r\n        );\r\n    }\r\n\r\n    mongooseOptions.mongooseSchema = mongooseSchema;\r\n    return mongooseOptions;\r\n  }\r\n\r\n  public static $register<T extends ModelType>(\r\n    this: T,\r\n    mongooseInstance?: Mongoose,\r\n  ): ConvertModel<InstanceType<T> & Document, InstanceType<T>> & T {\r\n    return registerMultiTenancy(this, mongooseInstance) as any;\r\n  }\r\n\r\n  public static $registerA7Model<T extends ModelType>(\r\n    this: T,\r\n    mongooseInstance?: Mongoose,\r\n  ): ConvertModel<InstanceType<T> & Document, InstanceType<T>> &\r\n    T &\r\n    A7ModelType {\r\n    return registerMultiTenancy(this, mongooseInstance) as any;\r\n  }\r\n}\r\n\r\nconst mongooseInstanceMap: {\r\n  [tenancy: string]: Mongoose;\r\n} = {};\r\n\r\nexport const lazyFns: string[] = [];\r\n\r\nexport const shareFns = ['on'];\r\n\r\nfunction registerMultiTenancy<T extends ModelType>(\r\n  model: T,\r\n  mongooseInstance?: Mongoose,\r\n): MModel<Document> & T {\r\n  if (!mongooseInstance) {\r\n    mongooseInstance = require('mongoose');\r\n    (mongooseInstance as any).sbaseConfig = sbaseMongooseConfig;\r\n  }\r\n\r\n  const sbaseConfig: SBaseMongooseConfig = (mongooseInstance as any)\r\n    .sbaseConfig;\r\n\r\n  if (!sbaseConfig.multiTenancy.enabled) {\r\n    const m = mongooseInstance.model(\r\n      model.name,\r\n      model.$mongooseOptions().mongooseSchema,\r\n    ) as any;\r\n\r\n    m.sbaseConfig = sbaseConfig;\r\n\r\n    return m;\r\n  }\r\n\r\n  const tenants = ['default'].concat(sbaseConfig.multiTenancy.tenants);\r\n  const tenantMap: {\r\n    [key: string]: MModel<Document> & T;\r\n  } = {};\r\n\r\n  for (const tenancy of tenants) {\r\n    let mi = mongooseInstanceMap[tenancy];\r\n\r\n    if (mi == null) {\r\n      mi = new Mongoose();\r\n      mi.connect(\r\n        sbaseConfig.multiTenancy.uris,\r\n        sbaseConfig.multiTenancy.options,\r\n        (err) => {\r\n          sbaseConfig.multiTenancy.onError(err, tenancy);\r\n        },\r\n      );\r\n      sbaseConfig.multiTenancy.onMongooseInstanceCreated(mi, tenancy);\r\n      mongooseInstanceMap[tenancy] = mi;\r\n    }\r\n\r\n    const m = mi.model(\r\n      model.name,\r\n      model.$mongooseOptions(sbaseConfig, tenancy).mongooseSchema,\r\n    ) as any;\r\n\r\n    m.sbaseConfig = sbaseConfig;\r\n\r\n    tenantMap[tenancy] = m;\r\n  }\r\n\r\n  const proxy: any = new Proxy<MModel<Document> & T>({} as any, {\r\n    get: (_obj: {}, prop: string) => {\r\n      if (prop === '$tenantMap') {\r\n        return tenantMap;\r\n      }\r\n\r\n      if (lazyFns.indexOf(prop) >= 0) {\r\n        const ret = function () {\r\n          const t = sbaseConfig.multiTenancy.tenancyFn(prop);\r\n          const m1: any = tenantMap[t];\r\n          const actualFn = m1[prop];\r\n\r\n          return actualFn.apply(this, arguments);\r\n        };\r\n        return ret;\r\n      }\r\n\r\n      if (shareFns.indexOf(prop) >= 0) {\r\n        const ret = (...args: any[]) => {\r\n          return _.map(tenants, (t) => {\r\n            const m2: any = tenantMap[t];\r\n            return m2[prop].apply(m2, args);\r\n          });\r\n        };\r\n        return ret;\r\n      }\r\n\r\n      const tenancy = sbaseConfig.multiTenancy.tenancyFn(prop);\r\n      const m: any = tenantMap[tenancy];\r\n      m._proxy = proxy;\r\n\r\n      if (prop === '$modelClass') {\r\n        return m;\r\n      }\r\n\r\n      const res = m[prop];\r\n      return _.isFunction(res) ? res.bind(m) : res;\r\n    },\r\n    set: (_obj: {}, prop: string, value: any) => {\r\n      const tenancy = sbaseConfig.multiTenancy.tenancyFn(prop);\r\n      const m: any = tenantMap[tenancy];\r\n      m[prop] = value;\r\n      return true;\r\n    },\r\n  });\r\n\r\n  return proxy;\r\n}\r\n\r\nexport interface DocumentModel extends Document {}\r\n\r\nexport class DocumentModel extends Model {\r\n  public static cast<D extends DocumentModel>(): IModel<D> {\r\n    return (this as any)._proxy || this;\r\n  }\r\n}\r\n\r\nconst SCHEMA_KEY = Symbol('sbase:schema');\r\nconst CONFIG_KEY = Symbol('sbase:config');\r\nconst PRE_KEY = Symbol('sbase:pre');\r\nconst POST_KEY = Symbol('sbase:post');\r\nconst VIRTUAL_KEY = Symbol('sbase:virtual');\r\nconst PLUGIN_KEY = Symbol('sbase:plugin');\r\nconst INDEX_KEY = Symbol('sbase:index');\r\nconst UPDATE_VALIDATOR_KEY = Symbol('sbase:updateValidator');\r\nconst MIXIN_KEY = Symbol('sbase:mixin');\r\nconst MONGOOSE_OPTIONS_KEY = Symbol('sbase:mongooseOptions');\r\n\r\nexport function Enum(e: any, schema: any = {}) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      type: String,\r\n      enum: Object.values(e).concat([null]),\r\n    }),\r\n  );\r\n}\r\n\r\nexport function DBRef(ref: string, schema: any = {}) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      type: SchemaTypes.ObjectId,\r\n      ref,\r\n    }),\r\n  );\r\n}\r\n\r\nexport function DBRefArray(ref: string, schema: any = {}) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      type: [\r\n        {\r\n          type: SchemaTypes.ObjectId,\r\n          ref,\r\n        },\r\n      ],\r\n    }),\r\n  );\r\n}\r\n\r\nexport function ArrayField(type: any, schema: any = {}) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      type: [type],\r\n      default: [],\r\n    }),\r\n  );\r\n}\r\n\r\nexport function Required(\r\n  opt: boolean | (() => boolean | Promise<boolean>) = true,\r\n  schema: any = {},\r\n) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      required: _.isFunction(opt) ? combineValidator(opt) : opt,\r\n    }),\r\n  );\r\n}\r\n\r\nexport function IndexField(schema: any = {}) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      index: true,\r\n    }),\r\n  );\r\n}\r\n\r\nexport function Unique(schema: any = {}) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      index: true,\r\n      unique: true,\r\n    }),\r\n  );\r\n}\r\n\r\nexport function Default(defaultValue: any, schema: any = {}) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      default: defaultValue,\r\n    }),\r\n  );\r\n}\r\n\r\nexport function MapField(type: any, schema: any = {}) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      type: Map,\r\n      of: type,\r\n    }),\r\n  );\r\n}\r\n\r\nexport function Optional(schema: any = {}) {\r\n  return Field(schema);\r\n}\r\n\r\nexport function Validate(validator: Validator, schema: any = {}) {\r\n  return Field(\r\n    _.extend({}, schema, {\r\n      validate: {\r\n        validator: combineValidator(validator.validator),\r\n        message: validator.message,\r\n      },\r\n    }),\r\n  );\r\n}\r\n\r\nexport function Field(schema: any = {}): PropertyDecorator {\r\n  function mapModelSchema(o: any): any {\r\n    if (_.isArray(o)) {\r\n      return _.map(o, (x) => mapModelSchema(x));\r\n    } else if (_.isFunction(o)) {\r\n      if (o.prototype instanceof Model) {\r\n        const func = Object.getOwnPropertyDescriptor(\r\n          o.__proto__,\r\n          '$mongooseOptions',\r\n        );\r\n        return func.value.call(o).mongooseSchema;\r\n      } else {\r\n        return o;\r\n      }\r\n    } else if (_.isObject(o) && o.__proto__.constructor.name === 'Object') {\r\n      return _.mapObject(o, (x) => mapModelSchema(x));\r\n    } else {\r\n      return o;\r\n    }\r\n  }\r\n\r\n  return (target: any, propertyName: string) => {\r\n    const schemas = Reflect.getOwnMetadata(SCHEMA_KEY, target) || {};\r\n    const existing = schemas[propertyName];\r\n\r\n    if (schema.type == null && existing == null) {\r\n      const type = Reflect.getMetadata('design:type', target, propertyName);\r\n      schema.type = type;\r\n    }\r\n\r\n    if (\r\n      _.isUndefined(schema.default) &&\r\n      schema.type &&\r\n      schema.type.prototype instanceof Model\r\n    ) {\r\n      schema.default = () => ({});\r\n    }\r\n\r\n    schemas[propertyName] = _.extend({}, existing, mapModelSchema(schema));\r\n    Reflect.defineMetadata(SCHEMA_KEY, schemas, target);\r\n  };\r\n}\r\n\r\nexport function Mixin(model: ModelType) {\r\n  return <T extends new (...args: any[]) => {}>(constructor: T) => {\r\n    const models: ModelType[] =\r\n      Reflect.getOwnMetadata(MIXIN_KEY, constructor.prototype) || [];\r\n\r\n    models.push(model);\r\n    Reflect.defineMetadata(MIXIN_KEY, models, constructor.prototype);\r\n  };\r\n}\r\n\r\nexport function Config(config: SchemaOptions) {\r\n  return <T extends new (...args: any[]) => {}>(constructor: T) => {\r\n    const configs: SchemaOptions =\r\n      Reflect.getOwnMetadata(CONFIG_KEY, constructor.prototype) || {};\r\n\r\n    _.extend(configs, config);\r\n    Reflect.defineMetadata(CONFIG_KEY, configs, constructor.prototype);\r\n  };\r\n}\r\n\r\nexport function Plugin(plugin: Plugin) {\r\n  return <T extends new (...args: any[]) => {}>(constructor: T) => {\r\n    const plugins: Plugin[] =\r\n      Reflect.getOwnMetadata(PLUGIN_KEY, constructor.prototype) || [];\r\n\r\n    plugins.push(plugin);\r\n    Reflect.defineMetadata(PLUGIN_KEY, plugins, constructor.prototype);\r\n  };\r\n}\r\n\r\nexport function Pre(pre: Pre) {\r\n  return <T extends new (...args: any[]) => {}>(constructor: T) => {\r\n    pushMetadata(PRE_KEY, constructor.prototype, pre);\r\n  };\r\n}\r\n\r\nexport function Pres(names: string[], pre: PPre) {\r\n  return <T extends new (...args: any[]) => {}>(constructor: T) => {\r\n    const pres = _.map(names, (name) => _.extend({ name }, pre));\r\n    pushMetadata(PRE_KEY, constructor.prototype, ...pres);\r\n  };\r\n}\r\n\r\nexport function Virtual(options: VirtualOptions) {\r\n  return (target: any, propertyName: string) => {\r\n    const virtuals: Virtual[] =\r\n      Reflect.getOwnMetadata(VIRTUAL_KEY, target) || [];\r\n    virtuals.push({\r\n      name: propertyName,\r\n      options,\r\n    });\r\n    Reflect.defineMetadata(VIRTUAL_KEY, virtuals, target);\r\n  };\r\n}\r\n\r\nexport function Post(post: Post) {\r\n  return <T extends new (...args: any[]) => {}>(constructor: T) => {\r\n    const posts: Post[] =\r\n      Reflect.getOwnMetadata(POST_KEY, constructor.prototype) || [];\r\n    posts.push(post);\r\n    Reflect.defineMetadata(POST_KEY, posts, constructor.prototype);\r\n  };\r\n}\r\n\r\nexport function Posts(names: string[], post: PPost) {\r\n  return <T extends new (...args: any[]) => {}>(constructor: T) => {\r\n    const posts: Post[] =\r\n      Reflect.getOwnMetadata(POST_KEY, constructor.prototype) || [];\r\n    for (const name of names) {\r\n      posts.push(_.extend({ name }, post));\r\n    }\r\n    Reflect.defineMetadata(POST_KEY, posts, constructor.prototype);\r\n  };\r\n}\r\n\r\nexport function Index(index: Index) {\r\n  return <T extends new (...args: any[]) => {}>(constructor: T) => {\r\n    const indexes: Index[] =\r\n      Reflect.getOwnMetadata(INDEX_KEY, constructor.prototype) || [];\r\n    indexes.push(index);\r\n    Reflect.defineMetadata(INDEX_KEY, indexes, constructor.prototype);\r\n  };\r\n}\r\n\r\nexport function UpdateValidator(validate: UpdateValidator) {\r\n  return <T extends new (...args: any[]) => {}>(constructor: T) => {\r\n    const validates: UpdateValidator[] =\r\n      Reflect.getOwnMetadata(UPDATE_VALIDATOR_KEY, constructor.prototype) || [];\r\n    validates.push(validate);\r\n    Reflect.defineMetadata(\r\n      UPDATE_VALIDATOR_KEY,\r\n      validates,\r\n      constructor.prototype,\r\n    );\r\n  };\r\n}\r\n\r\n/**\r\n * Mongoose options for current model.\r\n */\r\nexport interface MongooseOptions {\r\n  config?: SchemaOptions;\r\n  schema?: {};\r\n  mongooseSchema?: Schema;\r\n  pres?: Pre[];\r\n  posts?: Post[];\r\n  virtuals?: Virtual[];\r\n  methods?: Method[];\r\n  statics?: Method[];\r\n  plugins?: Plugin[];\r\n  indexes?: Index[];\r\n  updateValidators?: UpdateValidator[];\r\n}\r\n\r\nexport interface MongooseOptionsMap {\r\n  [key: string]: MongooseOptions;\r\n}\r\n\r\nexport interface Pre {\r\n  name: string;\r\n  fn: (next: (err?: NativeError) => void) => void;\r\n  parallel?: boolean;\r\n  errorCb?: (err: Error) => void;\r\n}\r\n\r\nexport interface PPre {\r\n  fn: (next: (err?: NativeError) => void) => void;\r\n  parallel?: boolean;\r\n  errorCb?: (err: Error) => void;\r\n}\r\n\r\nexport interface Post {\r\n  name: string;\r\n  fn: PostFn1 | PostFn2;\r\n}\r\n\r\nexport interface PPost {\r\n  fn: PostFn1 | PostFn2;\r\n}\r\n\r\nexport type PostFn1 = (doc: object, next: (err?: NativeError) => void) => void;\r\nexport type PostFn2 = (\r\n  error: MongoError,\r\n  doc: object,\r\n  next: (err?: NativeError) => void,\r\n) => void;\r\n\r\nexport interface Virtual {\r\n  name: string;\r\n  get?: () => any;\r\n  set?: (val?: any) => void;\r\n  options?: VirtualOptions;\r\n}\r\n\r\nexport interface Method {\r\n  name: string;\r\n  fn: () => void;\r\n}\r\n\r\nexport interface Plugin {\r\n  fn: (schema: Schema, options?: object) => void;\r\n  options?: object;\r\n  priority?: number;\r\n}\r\n\r\nexport interface Index {\r\n  fields: object;\r\n  options?: {\r\n    expires?: string;\r\n    [other: string]: any;\r\n  };\r\n}\r\n\r\nexport interface Validator {\r\n  validator: (v: any) => any;\r\n  message: string | ((props: { value: any }) => string);\r\n}\r\n\r\nexport interface UpdateValidator {\r\n  path: string;\r\n  fn: (val?: any) => boolean;\r\n  errorMsg?: string;\r\n  type?: string;\r\n}\r\n\r\nexport interface VirtualOptions {\r\n  ref: string;\r\n  localField: string;\r\n  foreignField: string;\r\n  justOne?: boolean;\r\n  options?: any;\r\n  count?: boolean;\r\n  match?: object;\r\n}\r\n\r\nexport class NativeError extends global.Error {}\r\n\r\nexport const preQueries = [\r\n  'find',\r\n  'findOne',\r\n  'count',\r\n  'findOneAndUpdate',\r\n  'findOneAndRemove',\r\n  'update',\r\n];\r\n\r\nconst STATIC_FILTER_NAMES = ['name', 'length', 'prototype'];\r\n\r\nexport function combineValidator<T>(\r\n  fn: (this: T, _v: any) => boolean | Promise<boolean>,\r\n): () => boolean | Promise<boolean> {\r\n  return function (this: T | Query<T>) {\r\n    if (this instanceof Query) {\r\n      return fn.apply(this.getUpdate().$set, arguments);\r\n    } else {\r\n      return fn.apply(this, arguments);\r\n    }\r\n  };\r\n}\r\n"],"sourceRoot":"D:\\zyq\\ark-db/src"}